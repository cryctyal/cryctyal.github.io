<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分享]]></title>
    <url>%2F2020%2F01%2F21%2F%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[今天听到了一首非常好听的歌曲，整个人一天都开心起来了，所以想和大家分享一下。 var ap = new APlayer({ element: document.getElementById("aplayer-QXbqkkPC"), narrow: false, autoplay: true, showlrc: false, music: { title: "倒带", author: "小仙女", url: "http://lc-gtwanmvr.cn-n1.lcfile.com/2d9f0d4d6c2b618751a2/《倒带》.m4a", pic: "http://lc-gTWANMvR.cn-n1.lcfile.com/fcc8b0b477df14d76794/100.jpeg", lrc: "" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap);]]></content>
      <categories>
        <category>分享</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Kafka学习(六)]]></title>
    <url>%2F2018%2F11%2F29%2FKafka%E5%AD%A6%E4%B9%A0(%E5%85%AD)%2F</url>
    <content type="text"><![CDATA[Kafka的几个特性 高吞吐量、低延迟：kafka每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。 可扩展性：kafka集群支持热扩展。 持久性、可靠性：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失。 容错性：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）。 高并发：支持数千个客户端同时读写。 一、可用性说到可用性，首先我们先学习一下Replica。 ReplicaKafka作为这么重要环节，如何保证高可用。 Kafka每个Partition的数据都会有多份Repalica，以此来保证Kafka的高可用。 Topic、Partition、Replica的关系如下图： Topic下会划分多个Partition，每个Partition都有自己的Replica，其中只有一个是Leader Replica，其余的是Follower Replica。 消息进来的时候会先存入Leader Replica，然后从Leader Replica复制到Follower Replica。只有复制全部完成时，Consumer才可以消费此条消息。这是为了确保意外发生时，数据可以恢复。Consumer的消费也是从Leader Replica读取的。 由此可见，Leader Replica做了大量的工作。所以如果不同Partition的Leader Replica在Kafka集群的Broker上分布不均匀，就会造成负载不均衡。 那么Kafka是如何保证负载均衡的呢？ Kafka通过轮询算法证Leader Replica是均匀分布在多个Broker上。如下图。 通过上图可以看到，每个Broker都只有一个Leader和一个Follower，都是均匀分布的。 关于Replica，有以下需要注意的： Replica均匀分配在Broker上，同一个Partition的Replica不会在同一个Broker上。（为了负载均衡） 同一个Partition的Replica数量不能多于Broker数量（否则就无法满足第一条）。 分区的Leader Replica均衡分布在Broker上。（这就叫做分区平衡） 分区平衡是个很重要的概念，接下来我们就来讲解分区平衡。 分区平衡 在讲分区平衡前，先讲几个概念： 1.AR： Assigned Replicas，已分配的副本。每个Partition都有自己的AR列表，里面存储着这个Partition最初分配的所有Replicas。AR列表一般不会变化，除非增加分区。 2.PR：优先Replicas。AR列表中的第一个Replicas就是优先Replicas，而且永远是优先Replicas。最初，优先Replicas和Leader Replicas是同一个Replicas。 3.ISR：In Sync Replicas，同步副本。每个Partition都有自己的ISR列表。ISR是会根据同步情况动态变化的。 最初ISR列表和AR列表是一致的，但由于某个节点死掉，或者某个节点的Follower Replicas落后Leader Replicas太多，那么该节点就会被从ISR列表中移除。此时，ISR和AR就不再一致。 接下来我们通过一个例子来理解分区平衡。 1.根据以上信息，一个拥有3个Replicas的Partition，最初是下图的样子。 可以看到AR和ISR保持一致，并且初始时刻优先副本和Leader副本都指向Replica 0. 2.接下来，Replica 0所在的机器下线了，那么情况会变成如下图所示： 可以看到Replica 0已经从ISR中移除掉了。同时，由于重新选举，Leader副本变成了Replica 1，而优先副本还是Replica 0。优先副本是不会改变的。 由于最初时，Leader副本在Broker均匀分布，分区是平衡的。但此时，由于此Partition的Leader副本换成了另外一个，所以此时分区平衡已经被破坏。 3.Replica 0所在的机器修复了，又重新上线，情况如下图： 可以看到Replica 0重新回到ISR列表中，不过此时他没能恢复Leader的身份。只能作为Follower当一名小弟。 此时分区依旧是不平衡的。那是否意味着分区永远都会不平衡下去呢？不是的。 4.Kafka会定时触发分区平衡操作，也可以主动触发分区平衡。这就是所谓的分区平衡操作，操作完后如下图。 可以看到此时Leader副本通过选举，会重新变回来replica 0，因为Replica 0是优先副本，其实优先的含义就是选择Leader时被优先选择。这样整个分区又回到了初始状态，而初始时，Leader副本是均匀分布的。此时已经分区平衡了。 由此可见，分区平衡操作就是使Leader副本和优先副本保持一致的操作。可以把优先副本理解为分区的平衡状态位，平衡操作就是让Leader副本归位。 如果你还是没有看明白，那我再给你讲一个故事 在班级里，老师按照考试分数选举班长，分数最好的的当班长。 AR就是老师的老师的班长选举顺序，ISR就是最近一次的考试分数列表。 刚开始学生A考的最好（Leader副本），所以学生A就当班长的最优人选（优先副本）。 第二次考试，学生A肚子不舒服，没有完整参加考试，有一门没有考。那这时学生A的分数肯定不算了（不在ISR列表中）。学生B考的最好（Leader副本），可是在老师和同学心目中，学生A才是最优人选啊（优先副本），怎么办呢？ 为了公平，老师决定老学生A补完没参加的那门考试，所以学生A最终的分数，又可以出现在分数列表中了（ISR）。 学生A还是很厉害的，不负所望还是考了第一，所以学生A还是这一次考的最好的（Leader副本）。也还是班长最优人选（优先副本）。 所以老师起到了分区平衡的作用，平衡了班级的氛围和公平竞争的规则！！！ 二、一致性上面的方案保证了数据高可用，有时高可用是体现在对一致性的牺牲上。如果希望达到强一致性，可以采取如下措施： 禁用脏leader选举，ISR没有node时，宁可不提供服务也不要未完全同步的node。 设置最小ISR数量min_isr，保证消息至少要被min_isr个node确认才能提交。 三、持久化kafka使用文件存储消息（Append Only Log），就是把这些消息全部存成一个有序日志，所有的消息发布者把消息发布到底端，从某一个逻辑上的位移开始顺序读取所有的消息。它的一个好处在于所有的读和写，尽管都是刷到磁盘上，但都是按照顺序进行，该方式对磁盘的使用比较有效。 文件缓存/直接内存映射等是常用的手段，因为Kafka是对日志文件进行Append操作，因此磁盘检索的开支是较小的。 同时为了减少磁盘写入的次数,Broker会将消息暂时Buffer起来，当消息的个数(或尺寸)达到一定阀值时，再Flush到磁盘，这样减少了磁盘IO调用的次数。对于Kafka而言，较高性能的磁盘，会带来更加直接的性能提升。 四、延展性如下图，Kafka提供Topic以及Partitions。每个用户有不同的Topic，每个Topic可以有多个Partitions，每个Partitions可被装载在不同的机器上。当用户提高规模之后，Kafka 只需要简单地增加机器和 Topic Partitions 数量，即可达到线性延展方式。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka学习(五)]]></title>
    <url>%2F2018%2F10%2F25%2FKafka%E5%AD%A6%E4%B9%A0(%E4%BA%94)%2F</url>
    <content type="text"><![CDATA[作为消息系统，Kafka是如何保证Consumer不会因为自身原因而漏消费消息呢？ Kafka将所有消息组织成多个Topic的形式存储，而每个Topic又可以拆分成多个Partition，每个Partition又由一个一个消息组成。每个消息都被标识了一个递增序列号代表其进来的先后顺序，并按顺序存储在Partition中。 这样，消息就以一个个id的方式，组织起来。 Consumer选择一个Topic，通过id指定从哪个位置开始消费消息。消费完成之后保留id，下次可以从这个位置开始继续消费，也可以从其他任意位置开始消费。上面的id在Kafka中称为Offset，这种组织和处理策略提供了如下好处： 消费者可以根据需求，灵活指定Offset消费。保证了消息不变性，为并发消费提供了线程安全的保证。每个Consumer都保留自己的Offset，互相之间不干扰，不存在线程安全问题。 讲个故事： 同学们被分配好了要研究的皇帝，开始转心的研究起来。可是要放学了，怎么记录上次研究到了哪一个地方呢？还好知乎提供了“页数”的功能，只要在底下跳转到哪一页就可以了。可是每次自己输入页数很麻烦，还要自己记住（Low Level API）！还好知乎的高级用户—会员，知乎会自动填充页数，不需要自己输入（High Level API）！ 我们再看下这张图，加深印象： 再加入几个知识点： 每个Partition都是有序的不可变的。 Kafka可以保证Partition的消费顺序，但不能保证Topic消费顺序。 无论消费与否，保留周期默认两天（可配置）。 每个Consumer维护的唯一元数据是Offset，代表消费的位置，一般线性向后移动。 Consumer也可以重置Offset到之前的位置，可以以任何顺序消费，不一定线性后移。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka学习(四)]]></title>
    <url>%2F2018%2F10%2F22%2FKafka%E5%AD%A6%E4%B9%A0(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[Kafka的Reblance策略。 Group中的Consumer是如何配合协调的呢？ ReblanceKafka有两种Reblance策略： Range Strategy：范围分区 RoundRobin Strategy：轮询分区 我们分别学习一下！ 一、Range StrategyRange 策略是对每个Topic而言的，首先对同一个Topic里面的Partition按照序号进行排序，并对Consumer按照字母顺序进行排序。 讲个故事： 小组分到的朝代有 10 个皇帝， 一共有3 个同学，排完序的皇帝是 0, 1, 2, 3, 4, 5, 6, 7, 8, 9；同学按照学号排序是C0, C1, C2。然后将皇帝的个数除于同学的总数来决定每个同学研究几个皇帝。如果除不尽，那么前面几个同学将会多研究一个皇帝。如果是有10个皇帝，那么结果就是：c0：0,1,2,3c1：4,5,6c2：7,8,9如果是有11个皇帝，那么结果就是：c0：0,1,2,3c1：4,5,6,7c2：8,9,10假如小组要研究两个朝代唐朝和宋朝，分别有10个皇帝，最后的分配结果将会是这样：C0：唐朝（0，1，2，3） 宋朝（0，1，2，3）C0：唐朝（4，5，6） 宋朝（4，5，6）C0：唐朝（7，8，9） 宋朝（7，8，9） 这样的分配策略弊端就是前面的Consumer者需要消费更多的Partition消息，负载更高，不平衡。 二、RoundRobin Strategy轮询分区策略是把所有的Partition和Consumer列出来，然后轮询Consumer和Partition，尽可能的让把Partition均匀的分配给Consumer。 讲个故事：* 假如有3个朝代 T0（三个皇帝P0-0，P0-1,P0-2），T1(两个皇帝P1-0,P1-1)，T2(四个皇帝P2-0，P2-1，P2-2，P2-3)有三个同学：C0(倾向于T0，T1),C1（倾向于T1，T2），C2(倾向于T0,T2)那么分区过程如下图所示 ：皇帝将会按照一定的顺序排列起来，同学按照倾向一个一个分配。P0-0分配给C0P0-1分配给C1但是C1并没订阅T0，于是跳过C1把P0-1分配给C2P0-2分配给C0P1-0分配给C1P1-1分配给C2但是C2并没订阅T1，于是跳过C2把P1-1分配给C0P2-0分配给C1P2-1分配给C2P2-2分配给C0但是C0并没订阅T2，于是跳过C0把P2-2分配给C1p2-3分配给C2所以结果就是：C0：P0-0，P0-2，P1-1C1：P1-0，P2-0，P2-2C2：P0-1，P2-1，P2-3 什么时候会触发Reblance策略重新分区？ Consumer增加或删除。 Partition的增加或者减少。 Broker的增加或者减少。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka学习(三)]]></title>
    <url>%2F2018%2F09%2F29%2FKafka%E5%AD%A6%E4%B9%A0(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[同学们已经分成小组学习了，但是小组内部怎么分呢？大家决定按照每个朝代的皇帝区分，这样可以把每个朝代的内容划分的更清楚。为了保证保证不会重复研究，每个皇帝只能被一位同学研究。可是有的小组同学人数不够，或者皇帝太多了怎么办呢？那就学习能力强的学霸多研究一些。学霸能力强，但是研究的数量比较多，效率肯定会有折扣，肯定比不上专心致志研究一位皇帝的同学。由于这种分配方式，小组内的同学肯定不会比被研究的皇帝还多，否则会有同学没有研究任务的情况出现。 在Kafka学习(二)中，我们说到同学们为了保证不重复研究同样的朝代，决定分组研究。那小组内的同学如何分工呢？如何保证小组内的同学不研究重复的内容呢？ 这里，就需要学习Kafka的一个核心概念 — Kafka如何保证高吞吐量。 Partition Kafka采用Partition的方式，使得Consumer能够做到并行消费，从而大大提高了自己的吞吐能力。 首先我们解释一下Partition的定义： Partition：Topic物理上的分组，一个Topic可以分为多个Partition，每个Partition是一个有序的队列。 Kafka中同一个Topic下的消息，存储在一个队列。Partition的概念就是把这个队列划分为若干个小队列，每一个小队列就是一个分区，如下图： 这样做的好处是什么呢？其实从上图已经可以看出来。无Partition时，一个Topic只有一个Consumer在消费这个消息队列。采用Partition后，如果有两个Partition，最多两个Consumer同时消费，消费的速度肯定会更快。如果觉得不够快，可以加到四个Partition，让四个Consumer并行消费。分区的设计大大的提升了kafka的吞吐量！！ 我们再结合下图继续学习Partition： 上图包含如下几个知识点： 一个Partition只能被同组的一个Consumer消费（图中只会有一个箭头指向一个Partition） 同一个组里的一个Consumer可以消费多个Partition（图中第一个Consumer消费Partition 0和3） 消费效率最高的情况是Partition和Consumer数量相同。这样确保每个Consumer专职负责一个Partition。 Consumer数量不能大于Partition数量。由于第一点的限制，当Consumer多于Partition时，就会有Consumer闲置。 Consumer Group可以认为是一个订阅者的集群，其中的每个Consumer负责自己所消费的Partition 我们再按照故事的方式总结一下： 讲个故事 同学们已经分成小组学习了，但是小组内部怎么分呢？大家决定按照每个朝代的皇帝区分，这样可以把每个朝代的内容划分的更清楚。 为了保证保证不会重复研究，每个皇帝只能被一位同学研究（一个Partition只能被同组的一个Consumer消费） 可是有的小组同学人数不够，或者皇帝太多了怎么办呢？那就学习能力强的学霸多研究一些（同一个组里的一个Consumer可以消费多个Partition） 学霸能力强，但是研究的数量比较多，效率肯定会有折扣，肯定比不上专心致志研究一位皇帝的同学。（消费效率最高的情况是Partition和Consumer数量相同。这样确保每个Consumer专职负责一个Partition。） 由于这种分配方式，小组内的同学肯定不会比被研究的皇帝还多，否则会有同学没有研究任务的情况出现。（Consumer数量不能大于Partition数量。）]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka学习(二)]]></title>
    <url>%2F2018%2F09%2F12%2FKafka%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[本来同学们分配的是每个人一个主题去研究，后来发现，内容太多了！怎么合理分配及时看完所有的主题并且保证不会浪费时间，即一个主题不会让多位同学研究呢？于是大家想到了分小组，A组看商朝的、B组看明朝的……这样一个主题看的人多了，研究起来也快了。 一、Kafka和其它消息系统有一个不一样的设计在Consumer之上加了一层Group。同一个Group的Consumer可以并行消费同一个topic的消息，但是同Group的Consumer，不会重复消费。如果同一个Topic需要被多次消费，可以通过设立多个Consumer Group来实现。每个Group分别消费，互不影响。 这就好比多个Consumer组成了一个团队，一起干活，当然干活的速度就上来了。 我们再看下面的架构图，可以发现Broker有一个角标，Leader和Follower，这是怎么回事呢？ 我们把集群架构剩下的几个名字定义解释一下： Broker：Kafka以集群的方式运行，可以由一个或多个服务组成，每个服务叫做一个Broker；一个Kafka节点就是一个Broker，多个Broker可以组成一个Kafka集群。Zookeeper集群：ZooKeeper是一个分布式的、分层级的文件系统，能促进客户端间的松耦合，并提供最终一致。 二、Kakfa Broker Leader的选举：Kakfa Broker集群受Zookeeper管理。所有的Kafka Broker节点一起去Zookeeper上注册一个临时节点，因为只有一个Kafka Broker会注册成功，其他的都会失败，所以这个成功在Zookeeper上注册临时节点的这个Kafka Broker会成为Kafka Broker Leader，其他的Kafka broker叫Kafka Broker Follower。 这个Leader会监听其他的Kafka Broker的所有信息，如果这个Kafka Broker Follower宕机了，在zookeeper上面的那个临时节点就会消失，此时所有的Kafka Broker又会一起去Zookeeper上注册一个临时节点。 三、Push模式和Pull模式这里你可能会有一个疑问，消息可以拉取，也可以被推送。在Kafka中，为什么Consumer是拉取消息而不是被推送消息呢？ 事实上，Push模式和Pull模式各有优劣。 Push模式很难适应消费速率不同的Consumer者，因为消息发送速率是由Broker决定的。Push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而Pull模式则可以根据Consumer的消费能力以适当的速率消费消息。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka学习(一)]]></title>
    <url>%2F2018%2F08%2F01%2FKafka%E5%AD%A6%E4%B9%A0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Kafka是什么？ 简介Kafka最初由Linkedin公司开发，是一个分布式、支持分区的、多副本的，基于zookeeper协调的分布式消息系统，它的最大的特性就是可以实时的处理大量数据以满足各种需求场景：比如基于hadoop的批处理系统、低延迟的实时系统、storm/Spark流式处理引擎，web/nginx日志、访问日志，消息服务等等，用scala语言编写，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。 Kafka是什么？ Kafka是一个流平台，在Kafka上可以发布和订阅流数据，并把它们保存起来、进行处理。 Kafka是一个分布式系统[^分布式系统]，以集群(支持自由伸缩)的方式运行，所以我们总称为分布式消息队列。 Kafka可以用来存储数据，数据存储的时间长短由你自己定义，并且只要数据还存储在Kafka中，你可以重复读取。 Kafka可以看成是实时版的Hadoop： Hadoop可以存储和定期处理大量的数据文件，而Kafka而可以存储和持续型的处理大型的数据流。 Hadoop主要应用于数据分析上，而Kafka因其低延迟的特点更合适应用于核心业务上，业务事件发生时，Kafka能够针对这些事件及时做出相应。 kafka的核心思想Kafka的核心思想就是把消息全部存成一个有序日志，所有的Producer把消息发布到底端，从某一个逻辑上的位移开始顺序读取所有的消息。 Kafka集群结构我们看下一Kafka的集群架构，如下图： 首先有两个名词定义：Producer和Consumer Producer：向Kafka Topic发布消息的程序。 Consumer：预订Topic并消费消息的程序。 这里又引出了Topic的定义： Topic：Kafka将消息以Topic为单位进行归纳，即消息的目录/主题。 讲个故事 我们平时看的知乎，里面有一些知乎主题，大家把与主题相关的内容都发布这个主题板块，如果你喜欢这个主题，可以点击关注主题，这样可以得到主题的最新的消息。有一天，老师让大家做一个关于中国历史各朝代皇帝的研究，同学们需要去寻找资料。大家发现知乎上有很多类似的话题，有商朝的，有唐朝的，有明朝的……每个朝代都分成了一个个主题，于是大家决定分配，每个人一个主题去研究。 这里知乎的主题相当于Kafka的Topic，是一堆消息的集合或者说是分类 在主题中发布内容的大牛相当于Kafka的Producer。 订阅主题，接受消息的学生相当于Kafka的Consumer。注意：有一个区别是知乎中的用户是被动推送的消息的，而Kafka中的Consumer是主动拉取消息的，这个我们后面会具体阐述。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议(二)]]></title>
    <url>%2F2018%2F06%2F08%2Fnetwork2%2F</url>
    <content type="text"><![CDATA[第二部分是一篇转载的老文章，源头出处未知，知乎上有人进行转载，把网关、DNS、DHCP、理由等概念讲的很清楚，拿来分享下。 网关假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。 但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。 DNS服务器假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话： 小不点：李大爷，我想找班主任查一下小明的电话号码行吗？ 李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚 了小明的电话）问到了，他家的号码是211.99.99.99 小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。 李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请 求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大 爷把电话给转到小明家） 就这样你和小明取得了联系。 DHCP服务器至于DHCP服务器嘛，可以这样比喻： 你家院子里的居民越来越多了，传达室李大爷那里的电话交换机已经不能满足这么多居民的需求了，所以只好采用了一种新技术叫做DHCP，居民们开机的时候随机得到一个电话号码，每一次得到的号码都可能会不同。 你家门口的李大爷：就是你的网关 你的班主任：就是你的DNS服务器 传达室的电话交换机：就是你的DHCP服务器。 路由同上，李大爷和王大爷之间的对话就叫做路由。另：如果还有个小朋友叫做小暗，他住的院子看门的是孙大爷，因为小暗的院子刚盖好，孙大爷刚来不久，他没有李大爷和王大爷办公室的电话（李大爷和王大爷当然也没有他的电话），这时会有两种情况： 1、居委会的赵大妈告诉了孙大爷关于李、王两位大爷的电话（同时赵大妈也告诉了李、王关于孙的电话），这就叫静态设定路由 2、赵大妈病了，孙大爷自己到处打电话，见人就说：“我是小暗他们院子管电话的”，结果被李、王二位听到了，就记在了他们的通讯录上，然后李、王就给孙大爷回了个电话说：“我是小明（小不点）他们院子管电话的”，这就叫动态设定路由 然后有一天小不点要找小暗，结果自然是小不点给李大爷打电话说：“大爷，我找小暗”（这里省略了李大爷去查小暗电话的过程，假设他知道小暗的电话），李大爷一找通讯录：“哦，小暗的院子的电话是孙大爷管着的，要找小暗自然先要通知孙大爷，我可以通知王大爷让他去找孙大爷，也可以自己直接找孙，那当然是自己直接找孙方便了”，于是李大爷给孙大爷打了电话，然后孙大爷又把电话转到了小暗家。 这里李大爷的通讯录叫做路由表。 李大爷选择是自己直接找孙大爷还是让王大爷帮忙转接叫做路由选择。 李大爷之所以选择直接找孙大爷是有依据的，因为他直接找孙大爷就能一步到位，如果要王大爷转接就需要两步才能完成，这里的“步”叫做“跳数”，李大爷的选择遵循的是最少步骤（跳数）原则（如果他不遵守这个原则，小不点可能就会多等些时间才能找到小暗，最终结果可能导致李大爷因工作不力被炒鱿鱼，这叫做“延时太长，选路原则不合理，换了一个路由器”） 路由欺骗和数据窃听当然，事情总是变化的，小不点和小明吵架了，这些天小不点老是给小暗打电话，小明心里想：“操，他是不是在说我坏话啊？”于是小明决定偷听小不点和小暗的通话，但是他又不能出院子，怎么办呢？小明做了这样一个决定： 首先他告诉自己院里管电话的王大爷说：“你给李大爷打个电话说小暗搬到咱们院子了，以后凡是打给他的电话我来接”，王大爷没反映过来（毕竟年纪大了啊！）就给李大爷打了电话，说：“现在我来管理小暗的电话了，孙已经不管了”，结果李大爷就把他的通讯录改了，这叫做路由欺骗。 以后小不点再找小暗，李大爷就转给王大爷了（其实应该转给孙大爷的），王大爷收到了这个电话就转给了小明（因为他之前已经和小明说好了），小明收到这个电话就假装小暗和小不点通信。因为小明作贼心虚，害怕明天小不点和小暗见面后当面问他，于是通信断了之后，又自己以小不点的名义给小暗通了个电话复述了一遍刚才的话，有这就叫数据窃听。 DDOS攻击再后来，小不点还是不断的和小暗联系，而零落了小明，小明心里嘀咕啊：“我不能总是这样以小暗的身份和小不点通话啊，外一有一天露馅了怎么办！”于是他想了一个更阴险的招数：“干脆我也不偷听你们的电话了，你小不点不是不给我打电话吗！那我让你也给小暗打不了，哼哼！”，他怎么做的呢？我们来看： 他联系了一批狐朋狗友，和他们串通好，每天固定一个时间大家一起给小暗院子传达室打电话，内容什么都有，只要传达室的孙爷爷接电话，就会听到“打雷啦，下雨收衣服啊！”、“人是人他妈生的，妖是妖他妈生的”、“你妈贵姓”等等，听的脑袋都大了，不听又不行，电话不停的响啊！终于有一天，孙爷爷忍不住了，大喊一声：“我受不了拉！！！！”，于是上吊自杀了！ 这就是最简单的DDOS攻击，孙爷爷心理承受能力弱的现象叫做“数据报处理模块有BUG”，孙爷爷的自杀叫做“路由器瘫痪”。如果是我，就会微笑着和他们拉家常，例如告诉他们“我早就听了天气预报，衣服10分钟前已经收好了”或者“那你妈是人还是妖”或者“和你奶奶一个姓”等等，我这种健全的心理叫做“健壮的数据报处理，能够抵御任何攻击” 孙爷爷瘫了之后，小不点终于不再给小暗打电话了，因为无论他怎么打对方都是忙音，这种现象叫做“拒绝服务”，所以小明的做法还有一个名字叫做“拒绝服务攻击”。 IP地址与MAC地址小明终于安静了几天，… 几天后，小明的院子来了一个美丽的女孩，名字叫做小丽，小明很喜欢她（小小年纪玩什么早恋！）可是小丽有个很帅的男朋友，小明干瞪眼没办法。当然这里还是要遵循上面的原则：小丽是不能出院子的。那个男的想泡小丽自然只能打电话，于是小明又蠢蠢欲动了： 还记得王爷爷是院子的电话总管吗？他之所以能管理电话是因为他有一个通讯录，因为同一个院子可能有2个孩子都叫小明，靠名字无法区分，所以通讯录上每一行只有两项： 门牌电话 一号门 1234567 （这个是小明的） 二号门 7654321 （这个是小丽的） …… 王爷爷记性不好，但这总不会错了吧（同一个院子不会有2个“二号门”吧）？每次打电话人家都要说出要找的电话号码，然后通过通讯录去院子里面敲门，比如人家说我找“1234567”，于是王爷爷一比较，哦，是一号门的，他就去敲一号门“听电话”，如果是找“7654321”，那他就找二号门“听电话”。 这里的电话号码就是传说中的“IP地址” 这里的门牌号就是传说中的网卡的’MAC‘地址（每一块网卡的MAC地址都是不一样的，这是网卡的制造商写死在网卡的芯片中的）。 ARP欺骗小明心里想“奶奶的，老子泡不到你也别想泡”，于是他打起了王爷爷通讯录的主意，经过细心的观察，周密的准备，他终于发现王爷爷有尿频的毛病（毕竟是老人啊…），终于在一个月黑风高的白天，王爷爷去上厕所了，小明偷偷的摸进传达室，小心翼翼的改了王爷爷的通讯录…… 过了几天，小丽的男朋友又给小丽打来了电话，对方报的电话是“7654321”，王爷爷一看通讯录，靠： 门牌电话 一号门 1234567 （这个是小明的） 一号门 7654321 （注意：这个原来是小丽的，但是被小明改了） …… 王爷爷不知道改了啊，于是就去找一号门的小明了，小明心里这个美啊，他以小丽父亲的口吻严厉的教训了那个男的和小丽之间不正当的男女关系，结果那个男的恭恭敬敬的挂了电话。当然小丽并不知道整个事情的发生… 这里小明的行为叫做“ARP欺骗”（因为在实际的网络上是通过发送ARP数据包来实现的，所以叫做“ARP欺骗”），王爷爷的通讯录叫做“ARP表” 这里要注意：王爷爷现在有两个通讯录了，一个是记录每个院子传达室电话的本本，叫做“路由表”，一个是现在说的记录院子里面详细信息的本本，叫做“ARP表”。 王爷爷的制度中有一条是这么写的“每个月要重新检查一下门牌号和电话的对应本（也就是ARP表）”，这个动作叫做“刷新ARP表”，每个月的时间限制叫做“刷新ARP表的周期”。这样小明为了让那个男的永远不能找到小丽，之后每个月都要偷偷改一次那个通讯录，不过这样也是不得不做的事啊！ 补充一点，小明是很聪明的，如果通讯录（ARP表）被改成了这样： 门牌（MAC）电话（IP） 一号门 1234567 （这个是小明的） 二号门 1234567 （注意：这个被小明改了，但是他一时头晕改错了） …… 就会是计算机就会弹出一个对话框提示“出现重复的IP地址”，最终会导致王爷爷不知所措，于是通知一号门和二号门，你们的电话重复了。这样小丽就知道有人在破坏她的好事，这个现象叫做“骗局被揭穿了” 小不点知道了小明偷听他和小暗的电话，于是就和小暗约定好了密码。小不点在家里把要说的加密了之后告诉小暗。土豆－〉星期三，地瓜－〉请客，笨蛋－〉小不点家。于是小不点告诉小暗：土豆笨蛋地瓜。小明听了？？？不懂。。。。郁闷了。。。这是加密。 除此之外，小丽也知道了小明改他家的电话号码了。于是王爷爷就登门一个一个把电话和门牌号记下来。并且藏起来不允许外人修改，只能自己有钥匙（密码）。这是ip地址和MAC地址绑定。当有人改了电话号码的时候，就得找王爷爷改。麻烦是麻烦了，但是安全了。不过小明偷偷的把王爷爷的钥匙偷配了一把（盗窃密码成功），于是他还可以修改。这样么，就这样了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议(一)]]></title>
    <url>%2F2018%2F06%2F08%2Fnetwork1%2F</url>
    <content type="text"><![CDATA[网络协议其实跟生活非常贴近，我们上网浏览新闻，聊天都跟它息息相关。但是因为网络协议众多，又特别抽象，对于很多非计算机专业的人来说，很难入门。很多大神推荐我看各种关于TCPIP的经典名著，说实话，每个字我都看得懂，但是合起来就蒙圈了。因此，结合生活例子，形象化的理解网络协议就特别重要。我写这系列文章的初衷是希望通过非技术视角，给出关于网络协议更接地气的解释，帮助更多小伙伴入门。 不懂计算机网络? 那先来发明一个互联网吧！我们驾驶着时光机回到了1960年，看着一台台巨无霸型的“个人电脑”，作为伟大的先（yi）知（yin）者，准备开始发明互联网，来连接这一台台电脑。我们想了一个法子：用一条条电线将电脑连接到一个黑盒子里，我们寄希望于这个伟大的黑盒子能帮助我们传递消息。我们迫不及待地打开电脑，想用Facebook发条状态，宣告我们伟大发明的诞生。咦，奇怪，怎么发不出去呢？计算机就像是一个个小婴儿一样，我们得教会他们行为、礼仪。比如如何去和其他计算机沟通交流，在不同场合需要注意些什么，并且把行为礼仪深深的印在他们脑海里。 因此，我们展开了一场盛大的互联网大会，会议中展开了热烈而富有成效的讨论，得出了结论：计算机之间的互相通信，每台计算机都要用相同的办法。比如如何探测到通信目标、由哪一边发起、使用何种语言进行沟通，如何结束通信等等。我们还考虑到了不同硬件、操作系统间的通信。因此我们一致同意，需要定制一系列的规则，统称为协议（protocol）。 协议中存在格式各样的内容，从电缆的规格到IP地址的选定办法、查找异地用户的方法、双方建立通讯的顺序，以及Web页面显示需要处理的步骤等等。我们很厉害有木有！我们给了这些互联网相关的协议集合一个酷炫的名称 - TCP/IP。那么有了这么多牛逼轰轰的协议，我们的消息又是怎么发出去的呢？ TCP/IP的分层TCP/IP 分为4层：应用层、传输层、网络层和数据链路层。为什么这么分呢？从事IT行业的小伙伴比较清楚，如果不分层，整个互联网只有一个协议，我们某个地方需要改动，就需要把整个协议替换掉，而如果进行分层，只需定义好各层的接口，以后如果有改动只需要改动相应的层即可。其次，每个层的角色也相对单一些，大大减少了设计的复杂度。 虽然我们为TCP/IP的4层取了牛逼哄哄的名字，我们借鉴了邮局寄信的逻辑。这里我们举个例子。 应用层产品经理小陈与程序员小徐是好基友，经常互相写信互诉衷肠。小陈有一天想小徐了，就写了一封满怀思念之情的信，但是小徐只看得懂中文，因此小陈还很贴心的标注了下，该文全程中文，无任何英文装逼词汇，最后画了一个小爱心后，把信装进信封里。 对于小陈来说，他关心的是信本身，但是没有信封、邮票，信就寄不出去。比如我们发出去的QQ信息，浏览的HTML内容，都属于应用数据。在网络中，我们想要发消息，也需要信封、邮票等等，而这些就是所谓的协议了。 我们在封装信后，填写信息，往往都是有步骤的，比如先填写收件人地址，和发件人地址，再填写收件人名称、寄件人名称等等。在网络协议中，也是类似的，先会封装应用层协议，再封装传输层协议，再封装网络层协议，最后给到链路层。 应用层作用就是定义信内容格式，它通过各种协议来规范数据格式(小陈标注了他是中文写的)，使程序方便识别。应用层常用协议有：DNS、HTTP、FTP、TELNET、SMTP等，这些协议规定了数据的格式，如json、txt、html等。收发双方都要遵循相同的协议格式进行数据传输。 网络层小陈开始写上信封的信息，写上了收件人地址，和发件人地址。 在计算机网络里，这个是网络层做的事情。收信人对应数据包里IP头部中的目的ip地址，寄件人对应数据包里IP头部中的源ip地址，写上寄信、收信两个地址就可以保证信件可以邮寄到目的地了。 传输层小陈开始填写收件人名称、寄件人名称。 小陈填写的这些信息可以理解为TCP协议（传输层）的头部数据。因此同一个地址，可能住了很多人，通过定义端口，确认主机上应用程序的身份，就可以将数据包交给对应的应用程序。 我们回顾下，在信封里包含的信息： 邮编：200000收件人：小徐发往：上海市金沙江路1038号寄件人：小陈寄自：上海市奉贤区 这张图摘自于图解HTTP,可以很清楚了解到在互联网中，发送一条消息时，时如何像封装一层层信息，来保证传输的。 小陈把信扔进信箱，过了几天，小徐就收到这封信了。 消息如何传送？信寄出去，会有人去信箱拿信，然后带到邮局，再进行分发。那计算机网络是如何把数据包传输到目的地的？比如我们的电脑在生成数据包时，明明输入的是一个域名，电脑是怎么知道对方电脑的IP地址的？（涉及到了DNS协议）。网络中的邮局又是谁呢？（涉及到了网关），网关又是如何帮我们把数据包传输到目的地的？（各种路由协议） 这些信息可以在网络协议(二)中得到比较好的解答。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IaaS、PaaS、SaaS的区别]]></title>
    <url>%2F2018%2F06%2F04%2FIaaS%E3%80%81PaaS%E3%80%81SaaS%2F</url>
    <content type="text"><![CDATA[工作中经常会遇到PaaS、SaaS这样的专用名词，一直很困惑，对于它们之间的区别也不清楚，所以我从网上整理了相关的介绍，作为笔记时刻阅读。 1.名词的定义 IaaS：基础设施服务，Infrastructure-as-a-service PaaS：平台服务，Platform-as-a-service SaaS：软件服务，Software-as-a-service 2.形象的比喻请设想你是一个餐饮业者，打算做披萨生意。你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。你有三个方案。 1. 方案一：IaaS他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。 2. 方案二：PaaS除了基础设施，他人还提供披萨饼皮。你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。 3.方案三：SaaS他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。 上面的三种方案，可以总结成下面这张图。 从左到右，自己承担的工作量（上图蓝色部分）越来越少，IaaS &gt; PaaS &gt; SaaS。 对应软件开发，则是下面这张图。 SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 SaaS，下面是一些例子。 客户管理服务 Salesforce团队协同服务 Google Apps储存服务 Box储存服务 Dropbox社交服务 Facebook / Twitter / Instagram PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。 HerokuGoogle App EngineOpenShift IaaS 是云服务的最底层，主要提供一些基础资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。 Amazon EC2Digital OceanRackSpace Cloud]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>IaaS</tag>
        <tag>PaaS</tag>
        <tag>SaaS</tag>
      </tags>
  </entry>
</search>
